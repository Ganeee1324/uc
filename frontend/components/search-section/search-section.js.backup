/**
 * Search Component JavaScript - Complete Functionality
 * Extracted from search.js for the search-section component
 */

// ===========================
// CONFIGURATION & CONSTANTS
// ===========================

// Add cache-busting timestamp to force browser refresh
const CACHE_BUSTER = Date.now();

// Development mode: Set to true to bypass backend and always show no results
const DEV_MODE_NO_RESULTS = false;

const API_BASE = window.APP_CONFIG?.API_BASE || 'https://symbia.it:5000';
let authToken = localStorage.getItem('authToken');

// ===========================
// DOM CACHE FOR PERFORMANCE
// ===========================

const DOM_CACHE = {
    documentsGrid: null,
    searchSection: null,
    documentCountContainer: null,
    documentCount: null,
    searchInput: null,
    init() {
        this.documentsGrid = document.getElementById('documentsGrid');
        this.searchSection = document.querySelector('.search-section');
        this.documentCountContainer = document.getElementById('documentCountContainer');
        this.documentCount = document.getElementById('documentCount');
        this.searchInput = document.getElementById('searchInput');
    },
    get(elementName) {
        if (!this[elementName]) {
            this.init();
        }
        return this[elementName];
    }
};

// ===========================
// GLOBAL STATE VARIABLES
// ===========================

let currentVetrine = [];
let currentFiles = [];
let originalFiles = []; // Keep original unfiltered data
let isFiltersOpen = false;

// ===========================
// FILTER MANAGER CLASS
// ===========================

class FilterManager {
    constructor() {
        this.filters = {};
        this.updateCountTimeout = null;
    }
    
    // Add or update a filter
    setFilter(key, value) {
        if (value === null || value === '' || value === undefined || 
            (Array.isArray(value) && value.length === 0)) {
            delete this.filters[key];
        } else {
            this.filters[key] = value;
        }
        this.debouncedUpdateCounts();
        this.updateActiveFiltersDisplay();
        
        // Save to localStorage whenever a filter is set
        saveFiltersToStorage();
    }
    
    // Remove a filter
    removeFilter(key) {
        delete this.filters[key];
        this.debouncedUpdateCounts();
        this.updateActiveFiltersDisplay();
        
        // Save to localStorage whenever a filter is removed
        saveFiltersToStorage();
    }
    
    // Get current filter count
    getActiveFilterCount() {
        const filters = this.filters || {};
        let count = 0;

        // Price range: count as 1 filter if changed from default
        const minPriceSet = filters.minPrice !== undefined && filters.minPrice !== 0;
        const maxPriceSet = filters.maxPrice !== undefined && filters.maxPrice !== 100;
        if (minPriceSet || maxPriceSet) {
            count += 1;
        }

        // Pages range: count as 1 filter if changed from default
        const minPagesSet = filters.minPages !== undefined && filters.minPages !== 1;
        const maxPagesSet = filters.maxPages !== undefined && filters.maxPages !== 1000;
        if (minPagesSet || maxPagesSet) {
            count += 1;
        }

        // All other filters (skip priceType if 'all')
        Object.entries(filters).forEach(([key, value]) => {
            if (
                key === "minPrice" || key === "maxPrice" ||
                key === "minPages" || key === "maxPages" ||
                (key === "priceType" && value === "all")
            ) {
                return;
            }
            if (value !== null && value !== undefined && value !== "") {
                count += 1;
            }
        });

        return { filters, count };
    }
    
    // Debounced count update to prevent race conditions
    debouncedUpdateCounts() {
        clearTimeout(this.updateCountTimeout);
        this.updateCountTimeout = setTimeout(() => {
            this.updateBottomFilterCount();
        }, 100);
    }
    
    // Updated count function that uses state instead of DOM counting
    updateBottomFilterCount() {
        const bottomFilterCountElement = document.getElementById('bottomFilterCount');
        const filterCountBadge = document.getElementById('filterCount');
        const activeCountObj = this.getActiveFilterCount();
        const activeCount = activeCountObj.count;
        
        // Update footer text
        if (bottomFilterCountElement) {
            bottomFilterCountElement.textContent = activeCount === 0 ? 'Nessun filtro attivo' : 
                activeCount === 1 ? '1 filtro attivo' : `${activeCount} filtri attivi`;
        }
        
        // Update badge
        if (filterCountBadge) {
            filterCountBadge.textContent = activeCount;
            if (activeCount > 0) {
                filterCountBadge.classList.add('active');
            } else {
                filterCountBadge.classList.remove('active');
            }
        }
    }
    
    // Enhanced display update with proper timing
    updateActiveFiltersDisplay() {
        const activeFiltersContainer = document.getElementById('activeFiltersDisplay');
        if (!activeFiltersContainer) return;
        
        // Clear existing pills
        activeFiltersContainer.innerHTML = '';
        const filters = this.filters;
        
        // Clear All pill (always first)
        const clearAllPill = document.createElement('div');
        clearAllPill.className = 'filter-pill clear-all-filters-btn sticky-left';
        clearAllPill.innerHTML = `
            <span class="filter-label">Rimuovi tutti</span>
            <button class="filter-remove" onclick="filterManager.clearAllFiltersAction()">
                <i class="material-symbols-outlined">close</i>
            </button>
        `;
        activeFiltersContainer.appendChild(clearAllPill);
        
        // Pages range pill
        const minPagesSet = filters.minPages !== undefined && filters.minPages !== 1;
        const maxPagesSet = filters.maxPages !== undefined && filters.maxPages !== 1000;
        if (minPagesSet || maxPagesSet) {
            const min = filters.minPages !== undefined ? filters.minPages : 1;
            const max = filters.maxPages !== undefined ? filters.maxPages : 1000;
            const pill = document.createElement('div');
            pill.className = 'filter-pill';
            pill.setAttribute('data-filter-key', 'pagesRange');
            pill.innerHTML = `
                <span class="filter-label">Pagine: ${min}-${max}</span>
                <button class="filter-remove" onclick="filterManager.removeFilter('minPages');filterManager.removeFilter('maxPages')">
                    <i class="material-symbols-outlined">close</i>
                </button>
            `;
            activeFiltersContainer.appendChild(pill);
        }
        
        // Price range pill
        const minPriceSet = filters.minPrice !== undefined && filters.minPrice !== 0;
        const maxPriceSet = filters.maxPrice !== undefined && filters.maxPrice !== 100;
        if (minPriceSet || maxPriceSet) {
            const min = filters.minPrice !== undefined ? filters.minPrice : 0;
            const max = filters.maxPrice !== undefined ? filters.maxPrice : 100;
            const pill = document.createElement('div');
            pill.className = 'filter-pill';
            pill.setAttribute('data-filter-key', 'priceRange');
            pill.innerHTML = `
                <span class="filter-label">Prezzo: €${min}-€${max}</span>
                <button class="filter-remove" onclick="filterManager.removeFilter('minPrice');filterManager.removeFilter('maxPrice')">
                    <i class="material-symbols-outlined">close</i>
                </button>
            `;
            activeFiltersContainer.appendChild(pill);
        }
        
        // All other filters
        Object.entries(filters).forEach(([key, value]) => {
            if (["minPages","maxPages","minPrice","maxPrice"].includes(key)) return;
            const pill = this.createFilterPill(key, value);
            activeFiltersContainer.appendChild(pill);
        });
        
        // Use proper timing for animations and count updates
        requestAnimationFrame(() => {
            activeFiltersContainer.classList.add('visible');
            // Ensure DOM is fully rendered before counting
            requestAnimationFrame(() => {
                this.updateBottomFilterCount();
            });
        });
    }
    
    // Helper function to create filter pills
    createFilterPill(key, value) {
        const pill = document.createElement('div');
        pill.className = 'filter-pill';
        pill.setAttribute('data-filter-key', key);
        
        // Display logic based on your filter types
        let displayText = '';
        if (typeof value === 'string') {
            displayText = value;
        } else if (Array.isArray(value)) {
            displayText = value.join(', ');
        } else {
            displayText = String(value);
        }
        
        pill.innerHTML = `
            <span class="filter-label">${key}: ${displayText}</span>
            <button class="filter-remove" onclick="filterManager.removeFilter('${key}')">
                <i class="material-symbols-outlined">close</i>
            </button>
        `;
        
        return pill;
    }

    // Clear all filters action
    clearAllFiltersAction() {
        this.filters = {};
        
        // Clear filters from localStorage
        try {
            localStorage.removeItem('searchFilters');
            localStorage.removeItem('searchTags');
        } catch (e) {
            console.warn('Could not clear filters from localStorage:', e);
        }
        
        // Reset all filter UI elements
        this.resetAllFilterUI();
        
        // Apply filters and render
        applyFiltersAndRender();
    }

    // Reset all filter UI elements
    resetAllFilterUI() {
        // Reset all dropdowns
        const dropdowns = ['faculty', 'course', 'canale', 'tag', 'vetrinaType'];
        dropdowns.forEach(type => {
            const input = document.getElementById(`${type}Filter`);
            if (input) {
                input.value = '';
                input.placeholder = this.getPlaceholderText(type);
            }
            
            const selectedOptions = document.getElementById(`${type}SelectedOptions`);
            if (selectedOptions) {
                selectedOptions.innerHTML = '';
            }
        });

        // Reset rating filter
        const ratingStars = document.querySelectorAll('.rating-filter-star');
        ratingStars.forEach(star => star.classList.remove('active'));

        // Reset price type
        const priceTypeRadios = document.querySelectorAll('input[name="priceType"]');
        priceTypeRadios.forEach(radio => {
            if (radio.value === 'all') {
                radio.checked = true;
            } else {
                radio.checked = false;
            }
        });

        // Reset price range
        const minPriceRange = document.getElementById('minPriceRange');
        const maxPriceRange = document.getElementById('maxPriceRange');
        const minPriceValue = document.getElementById('minPriceValue');
        const maxPriceValue = document.getElementById('maxPriceValue');
        
        if (minPriceRange) minPriceRange.value = 0;
        if (maxPriceRange) maxPriceRange.value = 100;
        if (minPriceValue) minPriceValue.textContent = '€0';
        if (maxPriceValue) maxPriceValue.textContent = '€100';

        // Reset pages range
        const minPagesRange = document.getElementById('minPagesRange');
        const maxPagesRange = document.getElementById('maxPagesRange');
        const minPagesValue = document.getElementById('minPagesValue');
        const maxPagesValue = document.getElementById('maxPagesValue');
        
        if (minPagesRange) minPagesRange.value = 1;
        if (maxPagesRange) maxPagesRange.value = 1000;
        if (minPagesValue) minPagesValue.textContent = '1';
        if (maxPagesValue) maxPagesValue.textContent = '1000';

        // Update slider fills
        updatePriceSliderFill();
        updatePagesSliderFill();

        // Update active filter indicators
        updateActiveFilterIndicators();
    }

    getPlaceholderText(type) {
        const placeholders = {
            faculty: 'Cerca facoltà...',
            course: 'Cerca corso...',
            canale: 'Cerca canale...',
            tag: 'Cerca tag...',
            vetrinaType: 'Seleziona tipo...'
        };
        return placeholders[type] || 'Cerca...';
    }
}

// Initialize the filter manager
const filterManager = new FilterManager();

// ===========================
// AUTHENTICATION & USER INFO
// ===========================

// Check if user is authenticated, but don't redirect - just return status
function checkAuthentication() {
    return !!authToken;
}

async function initializeUserInfo() {
    const user = await fetchCurrentUserData();
    updateHeaderUserInfo(user);
}

async function fetchCurrentUserData() {
    const cachedUser = localStorage.getItem('currentUser');
    if (cachedUser) {
        return JSON.parse(cachedUser);
    }
    return null;
}

function updateHeaderUserInfo(user) {
    const userAvatar = document.getElementById('userAvatar');
    const dropdownAvatar = document.getElementById('dropdownAvatar');
    const dropdownUserName = document.getElementById('dropdownUserName');
    const dropdownUserEmail = document.getElementById('dropdownUserEmail');
    
    if (user) {
        // Construct the user's full name for the avatar
        let fullName = '';
        if (user.name && user.surname) {
            fullName = `${user.name} ${user.surname}`;
        } else if (user.name) {
            fullName = user.name;
        } else if (user.username) {
            fullName = user.username;
        } else {
            fullName = 'User';
        }
        
        // Use consistent gradient avatar instead of UI Avatars service
        const gradientAvatar = createGradientAvatar(fullName, user.username);
        userAvatar.innerHTML = gradientAvatar;
        
        // Apply the same gradient to dropdown avatar
        if (dropdownAvatar) {
            const gradient = getConsistentGradient(user.username);
            dropdownAvatar.style.background = gradient;
            dropdownAvatar.textContent = getInitials(fullName);
            dropdownAvatar.style.color = 'white';
            dropdownAvatar.style.fontWeight = '700';
            dropdownAvatar.style.fontSize = '18px';
            dropdownAvatar.style.display = 'flex';
            dropdownAvatar.style.alignItems = 'center';
            dropdownAvatar.style.justifyContent = 'center';
        }
        
        if (dropdownUserName) {
            dropdownUserName.textContent = user.username || fullName;
        }
        if (dropdownUserEmail) {
            dropdownUserEmail.textContent = user.email;
        }
        
        // Handle hover and click for user avatar
        const userInfo = document.querySelector('.user-info');
        
        // Show dropdown on hover
        userAvatar.addEventListener('mouseenter', (event) => {
            event.stopPropagation();
            userInfo.classList.add('open');
        });
        
        // Hide dropdown when mouse leaves the user info area
        userInfo.addEventListener('mouseleave', (event) => {
            event.stopPropagation();
            userInfo.classList.remove('open');
        });
        
        // Redirect to v-dashboard when user clicks their avatar
        userAvatar.addEventListener('click', (event) => {
            event.stopPropagation();
            window.location.href = 'v-dashboard.html';
        });

        // Logout button
        const logoutBtn = document.getElementById('logoutBtn');
        if(logoutBtn) {
            logoutBtn.addEventListener('click', (e) => {
                e.preventDefault();
                logout();
            });
        }

    } else {
        // Handle case where user is not logged in - show login button
        userAvatar.innerHTML = `
            <button class="login-btn" onclick="window.location.href='index.html'">
                <span class="login-btn-text">Accedi</span>
            </button>
        `;
        
        // Remove dropdown functionality for non-authenticated users
        const userInfo = document.querySelector('.user-info');
        if (userInfo) {
            userInfo.classList.remove('open');
        }
    }
}

// ===========================
// EVENT HANDLERS - CSP COMPLIANT
// ===========================

function handleCSPEventHandlers() {
    document.addEventListener('click', function(e) {
        // Handle filter actions
        if (e.target.closest('[data-action="clear-all-filters"]')) {
            clearAllFiltersAction();
        }
        
        if (e.target.closest('[data-action="remove-filter"]')) {
            const element = e.target.closest('[data-action="remove-filter"]');
            const filterKey = element.getAttribute('data-filter-key');
            const specificValue = element.getAttribute('data-specific-value');
            if (filterKey) {
                removeActiveFilter(filterKey, e, specificValue);
            }
        }
        
        if (e.target.closest('[data-action="toggle-favorite"]')) {
            const element = e.target.closest('[data-action="toggle-favorite"]');
            toggleFavorite(element, e);
        }
        
        if (e.target.closest('[data-action="navigate"]')) {
            const element = e.target.closest('[data-action="navigate"]');
            const url = element.getAttribute('data-url');
            if (url) {
                window.location.href = url;
            }
        }
        
        if (e.target.closest('[data-action="download-document"]')) {
            const element = e.target.closest('[data-action="download-document"]');
            const fileId = element.getAttribute('data-file-id');
            if (fileId) {
                downloadDocument(fileId);
                closePreview();
            }
        }
        
        if (e.target.closest('[data-action="purchase-document"]')) {
            const element = e.target.closest('[data-action="purchase-document"]');
            const fileId = element.getAttribute('data-file-id');
            if (fileId) {
                purchaseDocument(fileId);
                closePreview();
            }
        }
        
        if (e.target.closest('[data-action="close-preview"]')) {
            closePreview();
        }
        
        if (e.target.closest('[data-action="view-full-document"]')) {
            const element = e.target.closest('[data-action="view-full-document"]');
            const docId = element.getAttribute('data-doc-id');
            if (docId) {
                window.location.href = `document-preview.html?id=${docId}`;
            }
        }
        
        if (e.target.closest('[data-action="add-to-cart"]')) {
            const element = e.target.closest('[data-action="add-to-cart"]');
            const docId = element.getAttribute('data-doc-id');
            if (docId) {
                addToCart(docId, e);
            }
        }
    });
}

// ===========================
// UTILITY FUNCTIONS FOR AVATARS
// ===========================

function getAvatarVariant(username) {
    if (!username) return 0;
    let hash = 0;
    for (let i = 0; i < username.length; i++) {
        hash = username.charCodeAt(i) + ((hash << 5) - hash);
    }
    return Math.abs(hash) % 8;
}

function getConsistentGradient(username) {
    const gradients = [
        'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
        'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
        'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
        'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
        'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)',
        'linear-gradient(135deg, #ff9a9e 0%, #fecfef 100%)',
        'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)'
    ];
    
    return gradients[getAvatarVariant(username)];
}

function createGradientAvatar(fullName, username) {
    const initials = getInitials(fullName);
    const gradient = getConsistentGradient(username);
    
    return `
        <div class="user-avatar-gradient" style="background: ${gradient}; width: 40px; height: 40px; border-radius: 50%; display: flex; align-items: center; justify-content: center; color: white; font-weight: 700; font-size: 16px; cursor: pointer;">
            ${initials}
        </div>
    `;
}

function getInitials(fullName) {
    if (!fullName) return 'U';
    const words = fullName.trim().split(' ');
    if (words.length === 1) {
        return words[0].charAt(0).toUpperCase();
    }
    return (words[0].charAt(0) + words[words.length - 1].charAt(0)).toUpperCase();
}

// ===========================
// HTTP REQUEST UTILITIES
// ===========================

async function makeRequest(url, options = {}) {
    try {
        const response = await fetch(url, {
            ...options,
            headers: {
                'Content-Type': 'application/json',
                ...(authToken && { 'Authorization': `Bearer ${authToken}` }),
                ...options.headers
            }
        });

        if (!response.ok) {
            if (response.status === 401) {
                // Token expired or invalid - remove it
                localStorage.removeItem('authToken');
                authToken = null;
                // Don't redirect, just return null to indicate unauthenticated
                return null;
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Request failed:', error);
        throw error;
    }
}

async function makeSimpleRequest(url) {
    try {
        const response = await fetch(url);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return await response.json();
    } catch (error) {
        console.error('Simple request failed:', error);
        throw error;
    }
}

async function makeAuthenticatedRequest(url) {
    if (!authToken) {
        return null;
    }
    
    try {
        const response = await fetch(url, {
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${authToken}`
            }
        });

        if (!response.ok) {
            if (response.status === 401) {
                localStorage.removeItem('authToken');
                authToken = null;
                return null;
            }
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        return await response.json();
    } catch (error) {
        console.error('Authenticated request failed:', error);
        return null;
    }
}

// ===========================
// LOADING STATES
// ===========================

function showLoadingCards(count = null) {
    const documentsGrid = DOM_CACHE.get('documentsGrid');
    if (!documentsGrid) return;

    // Determine count based on screen size if not provided
    if (count === null) {
        const screenWidth = window.innerWidth;
        if (screenWidth >= 1200) {
            count = 12; // 4 columns × 3 rows
        } else if (screenWidth >= 768) {
            count = 9; // 3 columns × 3 rows
        } else {
            count = 6; // 2 columns × 3 rows on mobile
        }
    }

    // Clear existing content
    documentsGrid.innerHTML = '';

    // Create loading cards
    for (let i = 0; i < count; i++) {
        const loadingCard = document.createElement('div');
        loadingCard.className = 'document-card loading';
        loadingCard.innerHTML = `
            <div class="document-image skeleton"></div>
            <div class="document-content">
                <div class="document-header">
                    <div class="skeleton skeleton-title"></div>
                    <div class="skeleton skeleton-subtitle"></div>
                </div>
                <div class="document-details">
                    <div class="skeleton skeleton-text"></div>
                    <div class="skeleton skeleton-text short"></div>
                </div>
                <div class="document-footer">
                    <div class="skeleton skeleton-price"></div>
                    <div class="skeleton skeleton-button"></div>
                </div>
            </div>
        `;
        
        // Add staggered animation delay
        loadingCard.style.animationDelay = `${i * 100}ms`;
        documentsGrid.appendChild(loadingCard);
    }

    // Update status
    showStatus('Caricamento documenti...', 'info');
}

// ===========================
// DATA LOADING FUNCTIONS
// ===========================

async function loadAllFiles() {
    try {
        console.log('🔄 Loading files from backend...');
        
        const data = await makeSimpleRequest(`${API_BASE}/api/vetrine`);
        
        if (!data || !data.vetrine) {
            console.error('❌ No vetrine data received');
            showNoResults();
            return;
        }
        
        console.log(`✅ Loaded ${data.vetrine.length} vetrine from backend`);
        currentVetrine = data.vetrine;
        
        // Extract files from vetrine with enhanced data structure
        originalFiles = [];
        
        for (const vetrina of currentVetrine) {
            if (vetrina.files && vetrina.files.length > 0) {
                for (const file of vetrina.files) {
                    originalFiles.push({
                        ...file,
                        vetrina_id: vetrina.id,
                        vetrina_info: {
                            name: vetrina.name,
                            description: vetrina.description,
                            rating: vetrina.rating || 0,
                            review_count: vetrina.review_count || 0,
                            faculty_name: vetrina.faculty_name,
                            course_name: vetrina.course_name,
                            canale: vetrina.canale,
                            tags: vetrina.tags || []
                        },
                        // Flatten some common properties for easier access
                        faculty_name: vetrina.faculty_name,
                        course_name: vetrina.course_name,
                        canale: vetrina.canale,
                        rating: vetrina.rating || 0,
                        review_count: vetrina.review_count || 0,
                        tags: vetrina.tags || []
                    });
                }
            }
        }
        
        console.log(`✅ Extracted ${originalFiles.length} files from vetrine`);
        
        // Load favorites status if authenticated
        if (checkAuthentication()) {
            await refreshFavoriteStatus();
        }
        
    } catch (error) {
        console.error('❌ Error loading files:', error);
        showError('Errore nel caricamento dei documenti');
    }
}

async function loadValidTags() {
    try {
        const data = await makeSimpleRequest(`${API_BASE}/api/tags`);
        if (data && data.tags) {
            window.validTags = data.tags;
            saveTagsToStorage(data.tags);
        }
    } catch (error) {
        console.warn('Could not load valid tags:', error);
        // Try to load from storage if available
        window.validTags = getSavedTags() || [];
    }
}

// ===========================
// DOCUMENT RENDERING
// ===========================

function renderDocuments(files) {
    const documentsGrid = DOM_CACHE.get('documentsGrid');
    const searchSection = DOM_CACHE.get('searchSection');
    
    if (!documentsGrid) return;

    if (!files || files.length === 0) {
        showNoResults();
        return;
    }

    // Clear loading cards
    documentsGrid.innerHTML = '';

    // Remove any no-results classes
    if (searchSection) {
        searchSection.classList.remove('no-results');
    }

    files.forEach((file, index) => {
        const card = createDocumentCard(file, index);
        documentsGrid.appendChild(card);
    });

    // Update document count
    updateDocumentCount(files.length);
    
    // Show success status
    showStatus(`${files.length} documenti trovati`, 'success');
}

function createDocumentCard(file, index) {
    const card = document.createElement('div');
    card.className = 'document-card';
    card.style.animationDelay = `${index * 50}ms`;

    // Generate preview icon based on file type
    const previewIcon = getDocumentPreviewIcon(file.filename);
    
    // Generate star rating
    const stars = generateStars(file.rating || 0);
    
    // Format price
    const price = formatPrice(file.price || 0);
    
    // Get file type and format file size
    const fileType = getFileTypeFromFilename(file.filename);
    const fileSize = formatFileSize(file.file_size || 0);
    
    // Format tags
    const tags = file.tags || [];
    const tagsHTML = tags.slice(0, 3).map(tag => `
        <span class="document-tag">${getTagDisplayName(tag)}</span>
    `).join('');

    card.innerHTML = `
        <div class="document-image-container">
            <div class="document-image">
                ${previewIcon}
            </div>
            <div class="document-overlay">
                <button class="preview-btn" onclick="previewDocument('${file.id}')">
                    <i class="material-symbols-outlined">visibility</i>
                    Anteprima
                </button>
            </div>
            <button class="favorite-btn ${file.is_favorite ? 'active' : ''}" 
                    data-action="toggle-favorite" 
                    data-file-id="${file.id}">
                <i class="material-symbols-outlined">${file.is_favorite ? 'favorite' : 'favorite_border'}</i>
            </button>
        </div>
        
        <div class="document-content">
            <div class="document-header">
                <h3 class="document-title">${file.vetrina_info?.name || file.title || 'Documento'}</h3>
                <div class="document-rating">
                    <div class="stars">${stars}</div>
                    <span class="rating-count">(${file.review_count || 0})</span>
                </div>
            </div>
            
            <div class="document-details">
                <div class="document-info">
                    <span class="document-faculty">${file.faculty_name || 'N/A'}</span>
                    <span class="document-course">${file.course_name || 'N/A'}</span>
                    ${file.canale ? `<span class="document-canale">${formatCanaleDisplay(file.canale)}</span>` : ''}
                </div>
                
                <div class="document-meta">
                    <span class="file-type">${fileType}</span>
                    <span class="file-size">${fileSize}</span>
                </div>
                
                ${tagsHTML ? `<div class="document-tags">${tagsHTML}</div>` : ''}
            </div>
            
            <div class="document-footer">
                <div class="document-price">
                    <span class="price">${price}</span>
                </div>
                <div class="document-actions">
                    ${file.price > 0 ? 
                        `<button class="add-to-cart-btn" data-action="add-to-cart" data-doc-id="${file.id}">
                            <i class="material-symbols-outlined">shopping_cart</i>
                            Carrello
                        </button>` :
                        `<button class="download-btn" data-action="download-document" data-file-id="${file.id}">
                            <i class="material-symbols-outlined">download</i>
                            Download
                        </button>`
                    }
                </div>
            </div>
        </div>
    `;

    return card;
}

function showNoResults() {
    const documentsGrid = DOM_CACHE.get('documentsGrid');
    const searchSection = DOM_CACHE.get('searchSection');
    
    if (!documentsGrid) return;

    documentsGrid.innerHTML = `
        <div class="no-results">
            <div class="no-results-content">
                <i class="material-symbols-outlined">search_off</i>
                <h3>Nessun documento trovato</h3>
                <p>Prova a modificare i tuoi filtri di ricerca o controlla l'ortografia.</p>
                <button class="clear-filters-btn" onclick="clearAllFiltersAction()">
                    <i class="material-symbols-outlined">clear_all</i>
                    Rimuovi tutti i filtri
                </button>
            </div>
        </div>
    `;

    if (searchSection) {
        searchSection.classList.add('no-results');
    }

    updateDocumentCount(0);
    showStatus('Nessun documento trovato', 'info');
}

function updateDocumentCount(count) {
    const documentCount = DOM_CACHE.get('documentCount');
    if (documentCount) {
        documentCount.textContent = count.toLocaleString();
    }
}

// ===========================
// UTILITY FUNCTIONS FOR DOCUMENTS
// ===========================

function getDocumentPreviewIcon(filename) {
    const extension = filename.split('.').pop().toLowerCase();
    const iconMap = {
        'pdf': '<i class="material-symbols-outlined">picture_as_pdf</i>',
        'doc': '<i class="material-symbols-outlined">description</i>',
        'docx': '<i class="material-symbols-outlined">description</i>',
        'ppt': '<i class="material-symbols-outlined">slideshow</i>',
        'pptx': '<i class="material-symbols-outlined">slideshow</i>',
        'xls': '<i class="material-symbols-outlined">table_chart</i>',
        'xlsx': '<i class="material-symbols-outlined">table_chart</i>',
        'txt': '<i class="material-symbols-outlined">article</i>',
        'zip': '<i class="material-symbols-outlined">folder_zip</i>',
        'rar': '<i class="material-symbols-outlined">folder_zip</i>'
    };
    
    return iconMap[extension] || '<i class="material-symbols-outlined">description</i>';
}

function getFileTypeFromFilename(filename) {
    if (!filename) return 'Documento';
    const extension = filename.split('.').pop().toLowerCase();
    const typeMap = {
        'pdf': 'PDF',
        'doc': 'Word',
        'docx': 'Word',
        'ppt': 'PowerPoint',
        'pptx': 'PowerPoint',
        'xls': 'Excel',
        'xlsx': 'Excel',
        'txt': 'Testo',
        'zip': 'Archivio',
        'rar': 'Archivio'
    };
    
    return typeMap[extension] || 'Documento';
}

function formatFileSize(bytes) {
    if (!bytes) return '0 B';
    const k = 1024;
    const sizes = ['B', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(1)) + ' ' + sizes[i];
}

function formatPrice(price) {
    if (!price || price === 0) return 'Gratuito';
    return `€${price.toFixed(2)}`;
}

function formatCanaleDisplay(canale) {
    if (!canale) return '';
    return `Canale ${canale}`;
}

function generateStars(rating) {
    const fullStars = Math.floor(rating);
    const hasHalfStar = rating % 1 >= 0.5;
    const emptyStars = 5 - fullStars - (hasHalfStar ? 1 : 0);
    
    let starsHTML = '';
    
    // Full stars
    for (let i = 0; i < fullStars; i++) {
        starsHTML += '<i class="material-symbols-outlined star filled">star</i>';
    }
    
    // Half star
    if (hasHalfStar) {
        starsHTML += '<i class="material-symbols-outlined star half">star_half</i>';
    }
    
    // Empty stars
    for (let i = 0; i < emptyStars; i++) {
        starsHTML += '<i class="material-symbols-outlined star">star_border</i>';
    }
    
    return starsHTML;
}

function getTagDisplayName(tag) {
    const tagNames = {
        'appunti': 'Appunti',
        'dispense': 'Dispense',
        'esami': 'Esami',
        'progetti': 'Progetti',
        'tesi': 'Tesi',
        'laboratorio': 'Laboratorio'
    };
    return tagNames[tag] || tag.charAt(0).toUpperCase() + tag.slice(1);
}

// ===========================
// FILTER SYSTEM
// ===========================

function initializeFilters() {
    const filtersBtn = document.getElementById('filtersBtn');
    const filtersPanel = document.getElementById('filtersPanel');
    const filtersOverlay = document.getElementById('filtersOverlay');
    const filtersClose = document.getElementById('filtersClose');
    const clearAllFilters = document.getElementById('clearAllFilters');

    // Filter panel toggle
    if (filtersBtn) filtersBtn.addEventListener('click', toggleFiltersPanel);
    if (filtersClose) filtersClose.addEventListener('click', closeFiltersPanel);
    if (filtersOverlay) filtersOverlay.addEventListener('click', closeFiltersPanel);

    // Filter actions
    if (clearAllFilters) clearAllFilters.addEventListener('click', clearAllFiltersAction);

    // Always set priceType to 'all' as default on initialization
    if (!filterManager.filters.priceType) {
        filterManager.filters.priceType = 'all';
    }

    // Initialize all filter controls
    initializeFilterControls();

    // Close on escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && isFiltersOpen) {
            closeFiltersPanel();
        }
    });
}

function initializeFilterControls() {
    // Professional dropdowns
    setupDropdowns();
    // Rating filter
    initializeRatingFilter();
    // Toggle group filters
    initializeToggleFilters();
    // Price range filters
    initializePriceRangeFilter();
    // Pages range filters
    initializePagesRangeFilter();
    // Order functionality
    initializeOrderDropdown();
    
    // Ensure price range is visible for 'Tutti' after all initializations
    const priceRangeContainer = document.getElementById('priceRangeContainer');
    if (filterManager.filters.priceType === 'all' && priceRangeContainer) {
        priceRangeContainer.style.display = 'block';
    }
}

function toggleFiltersPanel() {
    isFiltersOpen = !isFiltersOpen;
    const filtersPanel = document.getElementById('filtersPanel');
    const filtersOverlay = document.getElementById('filtersOverlay');
    const mainContent = document.querySelector('.main-content');
    const documentsGrid = document.getElementById('documentsGrid');
    
    if (isFiltersOpen) {
        if (filtersPanel) filtersPanel.classList.add('active');
        if (filtersOverlay) filtersOverlay.classList.add('active');
        if (mainContent) mainContent.classList.add('filters-open');
        if (documentsGrid) documentsGrid.classList.add('filters-open');
        document.body.classList.add('filters-open');
        document.body.style.overflow = 'hidden';
        
        // Add bottom clear all button if it doesn't exist
        addBottomClearAllButton();
        
        // Show price range if priceType is 'all'
        const priceRangeContainer = document.getElementById('priceRangeContainer');
        if (filterManager.filters.priceType === 'all' && priceRangeContainer) {
            priceRangeContainer.style.display = 'block';
        }
    } else {
        closeFiltersPanel();
    }
}

function closeFiltersPanel() {
    isFiltersOpen = false;
    const filtersPanel = document.getElementById('filtersPanel');
    const filtersOverlay = document.getElementById('filtersOverlay');
    const mainContent = document.querySelector('.main-content');
    const documentsGrid = document.getElementById('documentsGrid');
    
    if (filtersPanel) filtersPanel.classList.remove('active');
    if (filtersOverlay) filtersOverlay.classList.remove('active');
    if (mainContent) mainContent.classList.remove('filters-open');
    if (documentsGrid) documentsGrid.classList.remove('filters-open');
    document.body.classList.remove('filters-open');
    document.body.style.overflow = '';
}

function addBottomClearAllButton() {
    const filtersContent = document.querySelector('.filters-content');
    if (!filtersContent) return;
    
    // Check if bottom clear button already exists
    if (document.getElementById('bottomClearAllButton')) return;
    
    // Create bottom clear all button section
    const bottomClearSection = document.createElement('div');
    bottomClearSection.className = 'filters-bottom-actions';
    bottomClearSection.innerHTML = `
        <div class="bottom-clear-container">
            <button class="bottom-clear-all-btn" id="bottomClearAllButton" data-action="clear-all-filters">
                <i class="material-symbols-outlined">clear_all</i>
                <span>Rimuovi tutti i filtri</span>
            </button>
            <div class="bottom-clear-info">
                <span id="bottomFilterCount">0 filtri attivi</span>
            </div>
        </div>
    `;
    
    // Add to the end of filters content
    filtersContent.appendChild(bottomClearSection);
    
    // Update the bottom filter count
    updateBottomFilterCount();
}

function clearAllFiltersAction() {
    filterManager.clearAllFiltersAction();
}

// ===========================
// DROPDOWN SYSTEM
// ===========================

function setupDropdowns() {
    const dropdownTypes = ['faculty', 'course', 'canale', 'tag', 'vetrinaType'];
    
    dropdownTypes.forEach(type => {
        const container = document.getElementById(`${type}DropdownContainer`);
        const input = document.getElementById(`${type}Filter`);
        const dropdown = document.getElementById(`${type}Dropdown`);
        
        if (!container || !input || !dropdown) return;
        
        // Input focus/click
        input.addEventListener('focus', () => toggleDropdown(container, type));
        input.addEventListener('click', () => toggleDropdown(container, type));
        
        // Input typing
        input.addEventListener('input', (e) => {
            filterDropdownOptions(type, e.target.value);
        });
        
        // Keyboard navigation
        input.addEventListener('keydown', (e) => handleDropdownKeyboard(e, type));
    });
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.dropdown-container')) {
            closeAllDropdowns();
        }
    });
    
    // Populate dropdown options
    populateDropdownOptions();
}

function toggleDropdown(container, type) {
    const dropdown = container.querySelector('.dropdown-menu');
    const input = container.querySelector('.dropdown-input');
    
    closeAllDropdowns();
    
    container.classList.add('active');
    dropdown.style.display = 'block';
    
    // Position dropdown
    positionDropdown(input, dropdown);
    
    // Focus on input
    input.focus();
}

function positionDropdown(input, dropdown) {
    const inputRect = input.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const dropdownHeight = 300; // Max height
    
    // Check if there's enough space below
    const spaceBelow = viewportHeight - inputRect.bottom;
    const spaceAbove = inputRect.top;
    
    if (spaceBelow >= dropdownHeight || spaceBelow >= spaceAbove) {
        // Position below
        dropdown.style.top = '100%';
        dropdown.style.bottom = 'auto';
    } else {
        // Position above
        dropdown.style.top = 'auto';
        dropdown.style.bottom = '100%';
    }
}

function closeAllDropdowns() {
    const containers = document.querySelectorAll('.dropdown-container');
    containers.forEach(container => {
        container.classList.remove('active');
        const dropdown = container.querySelector('.dropdown-menu');
        if (dropdown) {
            dropdown.style.display = 'none';
        }
    });
}

function populateDropdownOptions() {
    if (!originalFiles || originalFiles.length === 0) return;
    
    // Extract unique values from files
    const faculties = [...new Set(originalFiles.map(f => f.faculty_name).filter(Boolean))];
    const courses = [...new Set(originalFiles.map(f => f.course_name).filter(Boolean))];
    const canales = [...new Set(originalFiles.map(f => f.canale).filter(Boolean))];
    const tags = [...new Set(originalFiles.flatMap(f => f.tags || []))];
    const vetrinaTypes = ['dispense', 'appunti', 'esami', 'progetti'];
    
    populateOptions('faculty', faculties.sort());
    populateOptions('course', courses.sort());
    populateOptions('canale', canales.sort());
    populateOptions('tag', tags.sort());
    populateOptions('vetrinaType', vetrinaTypes);
}

function populateOptions(type, items) {
    const dropdown = document.getElementById(`${type}Dropdown`);
    if (!dropdown) return;
    
    dropdown.innerHTML = items.map(item => `
        <div class="dropdown-option" data-value="${item}" onclick="selectDropdownOption('${type}', '${item}')">
            ${getTagDisplayName(item)}
        </div>
    `).join('');
}

function filterDropdownOptions(type, searchTerm) {
    const dropdown = document.getElementById(`${type}Dropdown`);
    if (!dropdown) return;
    
    const options = dropdown.querySelectorAll('.dropdown-option');
    const term = searchTerm.toLowerCase();
    
    options.forEach(option => {
        const text = option.textContent.toLowerCase();
        const value = option.getAttribute('data-value').toLowerCase();
        
        if (text.includes(term) || value.includes(term)) {
            option.style.display = 'block';
        } else {
            option.style.display = 'none';
        }
    });
}

function selectDropdownOption(type, value, displayText = null) {
    const input = document.getElementById(`${type}Filter`);
    const selectedOptions = document.getElementById(`${type}SelectedOptions`);
    
    if (!input) return;
    
    // For single-select filters
    if (['faculty', 'course', 'canale', 'vetrinaType'].includes(type)) {
        input.value = displayText || getTagDisplayName(value);
        filterManager.setFilter(type, value);
        closeAllDropdowns();
        applyFiltersAndRender();
        return;
    }
    
    // For multi-select filters (tags)
    if (type === 'tag') {
        if (!filterManager.filters[type]) {
            filterManager.filters[type] = [];
        }
        
        if (!filterManager.filters[type].includes(value)) {
            filterManager.filters[type].push(value);
            
            // Add selected option pill
            if (selectedOptions) {
                const pill = document.createElement('div');
                pill.className = 'selected-option-pill';
                pill.innerHTML = `
                    <span>${displayText || getTagDisplayName(value)}</span>
                    <button onclick="removeSpecificFilterValue('${type}', '${value}')">&times;</button>
                `;
                selectedOptions.appendChild(pill);
            }
            
            filterManager.setFilter(type, filterManager.filters[type]);
            applyFiltersAndRender();
        }
        
        // Clear input
        input.value = '';
        closeAllDropdowns();
    }
}

function removeSpecificFilterValue(type, value) {
    if (!filterManager.filters[type]) return;
    
    filterManager.filters[type] = filterManager.filters[type].filter(v => v !== value);
    
    if (filterManager.filters[type].length === 0) {
        delete filterManager.filters[type];
    }
    
    // Remove pill from UI
    const selectedOptions = document.getElementById(`${type}SelectedOptions`);
    if (selectedOptions) {
        const pills = selectedOptions.querySelectorAll('.selected-option-pill');
        pills.forEach(pill => {
            if (pill.textContent.includes(getTagDisplayName(value))) {
                pill.remove();
            }
        });
    }
    
    filterManager.setFilter(type, filterManager.filters[type]);
    applyFiltersAndRender();
}

function handleDropdownKeyboard(e, type) {
    const dropdown = document.getElementById(`${type}Dropdown`);
    if (!dropdown) return;
    
    const options = Array.from(dropdown.querySelectorAll('.dropdown-option:not([style*="display: none"])'));
    const currentHighlight = dropdown.querySelector('.dropdown-option.highlighted');
    let currentIndex = currentHighlight ? options.indexOf(currentHighlight) : -1;
    
    switch (e.key) {
        case 'ArrowDown':
            e.preventDefault();
            currentIndex = Math.min(currentIndex + 1, options.length - 1);
            highlightOption(options, currentIndex);
            break;
            
        case 'ArrowUp':
            e.preventDefault();
            currentIndex = Math.max(currentIndex - 1, 0);
            highlightOption(options, currentIndex);
            break;
            
        case 'Enter':
            e.preventDefault();
            if (currentHighlight) {
                const value = currentHighlight.getAttribute('data-value');
                selectDropdownOption(type, value);
            }
            break;
            
        case 'Escape':
            e.preventDefault();
            closeAllDropdowns();
            break;
    }
}

function highlightOption(options, index) {
    options.forEach(option => option.classList.remove('highlighted'));
    if (options[index]) {
        options[index].classList.add('highlighted');
    }
}

// ===========================
// RATING FILTER
// ===========================

function initializeRatingFilter() {
    const ratingStars = document.querySelectorAll('.rating-filter-star');
    
    ratingStars.forEach((star, index) => {
        const rating = index + 1;
        
        star.addEventListener('click', () => {
            // Toggle rating filter
            if (filterManager.filters.minRating === rating) {
                // Remove rating filter
                delete filterManager.filters.minRating;
            } else {
                // Set rating filter
                filterManager.filters.minRating = rating;
            }
            
            // Update UI
            updateRatingFilterUI();
            filterManager.setFilter('minRating', filterManager.filters.minRating);
            applyFiltersAndRender();
        });
        
        // Hover effects
        star.addEventListener('mouseenter', () => {
            highlightRatingStars(rating);
        });
        
        star.addEventListener('mouseleave', () => {
            updateRatingFilterUI();
        });
    });
}

function updateRatingFilterUI() {
    const ratingStars = document.querySelectorAll('.rating-filter-star');
    const minRating = filterManager.filters.minRating || 0;
    
    ratingStars.forEach((star, index) => {
        if (index < minRating) {
            star.classList.add('active');
        } else {
            star.classList.remove('active');
        }
    });
}

function highlightRatingStars(rating) {
    const ratingStars = document.querySelectorAll('.rating-filter-star');
    
    ratingStars.forEach((star, index) => {
        if (index < rating) {
            star.classList.add('active');
        } else {
            star.classList.remove('active');
        }
    });
}

// ===========================
// TOGGLE FILTERS (PRICE TYPE, VETRINA TYPE)
// ===========================

function initializeToggleFilters() {
    // Price type filter
    const priceTypeRadios = document.querySelectorAll('input[name="priceType"]');
    const priceRangeContainer = document.getElementById('priceRangeContainer');
    
    // Set default to 'all'
    filterManager.filters.priceType = 'all';
    
    priceTypeRadios.forEach(radio => {
        if (radio.value === 'all') {
            radio.checked = true;
        }
        
        radio.addEventListener('change', () => {
            if (radio.checked) {
                if (radio.value === 'all') {
                    filterManager.filters.priceType = 'all';
                } else {
                    filterManager.filters.priceType = radio.value;
                }
                
                // Show/hide price range based on selection
                if (priceRangeContainer && filterManager.filters.priceType === 'all') {
                    priceRangeContainer.style.display = 'block';
                } else if (priceRangeContainer) {
                    priceRangeContainer.style.display = 'none';
                }
                
                // Handle price range logic
                if (radio.value === 'free') {
                    filterManager.filters.priceType = 'free';
                } else if (radio.value === 'paid') {
                    filterManager.filters.priceType = 'paid';
                } else {
                    // 'all' selected - use price range if set
                    if (filterManager.filters.minPrice !== undefined || filterManager.filters.maxPrice !== undefined) {
                        const minVal = filterManager.filters.minPrice || 0;
                        const maxVal = filterManager.filters.maxPrice || 100;
                        filterManager.filters.minPrice = minVal;
                        filterManager.filters.maxPrice = maxVal;
                    }
                }
                
                filterManager.setFilter('priceType', filterManager.filters.priceType);
                applyFiltersAndRender();
            }
        });
    });
    
    // Vetrina type filter
    const vetrinaTypeRadios = document.querySelectorAll('input[name="vetrinaType"]');
    vetrinaTypeRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            if (radio.checked) {
                const vetrinaType = radio.value;
                filterManager.filters.vetrinaType = vetrinaType;
                filterManager.setFilter('vetrinaType', vetrinaType);
                applyFiltersAndRender();
            }
        });
    });
}

// ===========================
// PRICE RANGE FILTER
// ===========================

function initializePriceRangeFilter() {
    const minPriceRange = document.getElementById('minPriceRange');
    const maxPriceRange = document.getElementById('maxPriceRange');
    const minPriceValue = document.getElementById('minPriceValue');
    const maxPriceValue = document.getElementById('maxPriceValue');
    
    if (!minPriceRange || !maxPriceRange) return;
    
    const debouncedHandler = debounce(handlePriceRangeChange, 300);
    
    minPriceRange.addEventListener('input', debouncedHandler);
    maxPriceRange.addEventListener('input', debouncedHandler);
    
    // Initialize values
    updatePriceSliderFill();
}

function handlePriceRangeChange() {
    const minPriceRange = document.getElementById('minPriceRange');
    const maxPriceRange = document.getElementById('maxPriceRange');
    const minPriceValue = document.getElementById('minPriceValue');
    const maxPriceValue = document.getElementById('maxPriceValue');
    
    if (!minPriceRange || !maxPriceRange) return;
    
    let minVal = parseInt(minPriceRange.value);
    let maxVal = parseInt(maxPriceRange.value);
    
    // Ensure min is not greater than max
    if (minVal > maxVal) {
        minVal = maxVal;
        minPriceRange.value = minVal;
    }
    
    // Update display values
    if (minPriceValue) minPriceValue.textContent = `€${minVal}`;
    if (maxPriceValue) maxPriceValue.textContent = `€${maxVal}`;
    
    // Update slider fill
    updatePriceSliderFill();
    
    // Apply filters
    applyPriceFilters(minVal, maxVal);
}

function updatePriceSliderFill() {
    const minPriceRange = document.getElementById('minPriceRange');
    const maxPriceRange = document.getElementById('maxPriceRange');
    const sliderFill = document.querySelector('.price-slider-fill');
    
    if (!minPriceRange || !maxPriceRange || !sliderFill) return;
    
    const min = parseInt(minPriceRange.min);
    const max = parseInt(minPriceRange.max);
    const minVal = parseInt(minPriceRange.value);
    const maxVal = parseInt(maxPriceRange.value);
    
    const minPercent = ((minVal - min) / (max - min)) * 100;
    const maxPercent = ((maxVal - min) / (max - min)) * 100;
    
    sliderFill.style.left = `${minPercent}%`;
    sliderFill.style.width = `${maxPercent - minPercent}%`;
}

function applyPriceFilters(minVal, maxVal) {
    // Always set priceType to 'all' when using price range
    filterManager.filters.priceType = 'all';
    
    // Only set price filters if they differ from defaults
    if (filterManager.filters.priceType === 'paid' || filterManager.filters.priceType === 'all') {
        filterManager.filters.minPrice = minVal;
        filterManager.filters.maxPrice = maxVal;
    }
    
    filterManager.setFilter('minPrice', minVal);
    filterManager.setFilter('maxPrice', maxVal);
    applyFiltersAndRender();
}

// ===========================
// PAGES RANGE FILTER
// ===========================

function initializePagesRangeFilter() {
    const minPagesRange = document.getElementById('minPagesRange');
    const maxPagesRange = document.getElementById('maxPagesRange');
    
    if (!minPagesRange || !maxPagesRange) return;
    
    const debouncedHandler = debounce(handlePagesRangeChange, 300);
    
    minPagesRange.addEventListener('input', debouncedHandler);
    maxPagesRange.addEventListener('input', debouncedHandler);
    
    // Initialize values
    updatePagesSliderFill();
}

function handlePagesRangeChange() {
    const minPagesRange = document.getElementById('minPagesRange');
    const maxPagesRange = document.getElementById('maxPagesRange');
    const minPagesValue = document.getElementById('minPagesValue');
    const maxPagesValue = document.getElementById('maxPagesValue');
    
    if (!minPagesRange || !maxPagesRange) return;
    
    let minVal = parseInt(minPagesRange.value);
    let maxVal = parseInt(maxPagesRange.value);
    
    // Ensure min is not greater than max
    if (minVal > maxVal) {
        minVal = maxVal;
        minPagesRange.value = minVal;
    }
    
    // Update display values
    if (minPagesValue) minPagesValue.textContent = minVal;
    if (maxPagesValue) maxPagesValue.textContent = maxVal;
    
    // Update slider fill
    updatePagesSliderFill();
    
    // Apply filters
    applyPagesFilters(minVal, maxVal);
}

function updatePagesSliderFill() {
    const minPagesRange = document.getElementById('minPagesRange');
    const maxPagesRange = document.getElementById('maxPagesRange');
    const sliderFill = document.querySelector('.pages-slider-fill');
    
    if (!minPagesRange || !maxPagesRange || !sliderFill) return;
    
    const min = parseInt(minPagesRange.min);
    const max = parseInt(minPagesRange.max);
    const minVal = parseInt(minPagesRange.value);
    const maxVal = parseInt(maxPagesRange.value);
    
    const minPercent = ((minVal - min) / (max - min)) * 100;
    const maxPercent = ((maxVal - min) / (max - min)) * 100;
    
    sliderFill.style.left = `${minPercent}%`;
    sliderFill.style.width = `${maxPercent - minPercent}%`;
}

function applyPagesFilters(minVal, maxVal) {
    filterManager.filters.minPages = minVal;
    filterManager.filters.maxPages = maxVal;
    
    filterManager.setFilter('minPages', minVal);
    filterManager.setFilter('maxPages', maxVal);
    applyFiltersAndRender();
}

// ===========================
// ORDER/SORTING DROPDOWN
// ===========================

function initializeOrderDropdown() {
    const orderBtn = document.getElementById('orderBtn');
    const orderDropdown = document.getElementById('orderDropdown');
    const orderOptions = document.querySelectorAll('.order-option');
    
    if (!orderBtn || !orderDropdown) return;
    
    // Toggle dropdown
    orderBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        orderDropdown.classList.toggle('active');
    });
    
    // Close dropdown when clicking outside
    document.addEventListener('click', (e) => {
        if (!e.target.closest('.order-dropdown')) {
            orderDropdown.classList.remove('active');
        }
    });
    
    // Handle order selection
    orderOptions.forEach(option => {
        option.addEventListener('click', () => {
            const orderType = option.getAttribute('data-order');
            selectOrderOption(orderType);
        });
    });
}

function selectOrderOption(orderType) {
    const orderBtn = document.getElementById('orderBtn');
    const orderDropdown = document.getElementById('orderDropdown');
    const orderOptions = document.querySelectorAll('.order-option');
    
    // Update button text
    const orderTexts = {
        'relevance': 'Rilevanza',
        'rating-desc': 'Valutazione ↓',
        'rating-asc': 'Valutazione ↑',
        'price-desc': 'Prezzo ↓',
        'price-asc': 'Prezzo ↑',
        'name-asc': 'Nome A-Z',
        'name-desc': 'Nome Z-A'
    };
    
    if (orderBtn) {
        orderBtn.innerHTML = `
            <span>${orderTexts[orderType] || 'Ordina per'}</span>
            <i class="material-symbols-outlined">keyboard_arrow_down</i>
        `;
    }
    
    // Update active option
    orderOptions.forEach(option => {
        if (option.getAttribute('data-order') === orderType) {
            option.classList.add('active');
        } else {
            option.classList.remove('active');
        }
    });
    
    // Close dropdown
    if (orderDropdown) {
        orderDropdown.classList.remove('active');
    }
    
    // Apply ordering
    filterManager.setFilter('orderBy', orderType);
    applyOrderToResults();
}

function applyOrderToResults() {
    if (!currentFiles || currentFiles.length === 0) return;
    
    const orderType = filterManager.filters.orderBy || 'relevance';
    const sortedFiles = sortDocuments([...currentFiles], orderType);
    
    renderDocuments(sortedFiles);
}

function sortDocuments(documents, orderType) {
    switch (orderType) {
        case 'rating-desc':
            return documents.sort((a, b) => (b.rating || 0) - (a.rating || 0));
            
        case 'rating-asc':
            return documents.sort((a, b) => (a.rating || 0) - (b.rating || 0));
            
        case 'price-desc':
            return documents.sort((a, b) => (b.price || 0) - (a.price || 0));
            
        case 'price-asc':
            return documents.sort((a, b) => (a.price || 0) - (b.price || 0));
            
        case 'name-asc':
            return documents.sort((a, b) => {
                const nameA = (a.vetrina_info?.name || a.title || '').toLowerCase();
                const nameB = (b.vetrina_info?.name || b.title || '').toLowerCase();
                return nameA.localeCompare(nameB);
            });
            
        case 'name-desc':
            return documents.sort((a, b) => {
                const nameA = (a.vetrina_info?.name || a.title || '').toLowerCase();
                const nameB = (b.vetrina_info?.name || b.title || '').toLowerCase();
                return nameB.localeCompare(nameA);
            });
            
        case 'relevance':
        default:
            return documents; // Keep original order for relevance
    }
}

// ===========================
// FILTER APPLICATION & RENDERING
// ===========================

async function applyFiltersAndRender() {
    if (!originalFiles || originalFiles.length === 0) {
        showNoResults();
        return;
    }
    
    // Apply filters to get filtered results
    currentFiles = applyFiltersToFiles(originalFiles);
    
    // Apply sorting
    const orderType = filterManager.filters.orderBy || 'relevance';
    currentFiles = sortDocuments(currentFiles, orderType);
    
    // Render results
    renderDocuments(currentFiles);
    
    // Update filter displays
    updateActiveFilterIndicators();
    updateActiveFiltersDisplay();
}

function applyFiltersToFiles(files) {
    if (!filterManager.filters || Object.keys(filterManager.filters).length === 0) {
        return files;
    }
    
    return files.filter(file => {
        // Faculty filter
        if (filterManager.filters.faculty && Array.isArray(filterManager.filters.faculty)) {
            const hasMatchingFaculty = filterManager.filters.faculty.some(selectedFaculty => 
                file.faculty_name && file.faculty_name.toLowerCase().includes(selectedFaculty.toLowerCase())
            );
            if (!hasMatchingFaculty) return false;
        } else if (filterManager.filters.faculty && typeof filterManager.filters.faculty === 'string') {
            if (!file.faculty_name || !file.faculty_name.toLowerCase().includes(filterManager.filters.faculty.toLowerCase())) {
                return false;
            }
        }
        
        // Course filter
        if (filterManager.filters.course && Array.isArray(filterManager.filters.course)) {
            const hasMatchingCourse = filterManager.filters.course.some(selectedCourse => 
                file.course_name && file.course_name.toLowerCase().includes(selectedCourse.toLowerCase())
            );
            if (!hasMatchingCourse) return false;
        } else if (filterManager.filters.course && typeof filterManager.filters.course === 'string') {
            if (!file.course_name || !file.course_name.toLowerCase().includes(filterManager.filters.course.toLowerCase())) {
                return false;
            }
        }
        
        // Canale filter
        if (filterManager.filters.canale) {
            if (!file.canale || file.canale !== filterManager.filters.canale) {
                return false;
            }
        }
        
        // Tag filter
        if (filterManager.filters.tag && Array.isArray(filterManager.filters.tag) && filterManager.filters.tag.length > 0) {
            const fileTags = file.tags || [];
            const hasMatchingTag = filterManager.filters.tag.some(selectedTag => 
                fileTags.some(fileTag => 
                    fileTag.toLowerCase() === selectedTag.toLowerCase()
                )
            );
            if (!hasMatchingTag) return false;
        }
        
        // Rating filter
        if (filterManager.filters.minRating) {
            const fileRating = file.rating || 0;
            if (fileRating < filterManager.filters.minRating) {
                return false;
            }
        }
        
        // Price type filter
        const filePrice = file.price || 0;
        if (filterManager.filters.priceType === 'free' && filePrice > 0) {
            return false;
        }
        if (filterManager.filters.priceType === 'paid' && filePrice === 0) {
            return false;
        }
        
        // Price range filter (only applies when priceType is 'all' or 'paid')
        if (filterManager.filters.minPrice !== undefined || filterManager.filters.maxPrice !== undefined) {
            const filePrice = file.price || 0;
            
            if (filterManager.filters.minPrice !== undefined && filePrice < filterManager.filters.minPrice) {
                return false;
            }
            
            if (filterManager.filters.maxPrice !== undefined && filePrice > filterManager.filters.maxPrice) {
                return false;
            }
        }
        
        // Vetrina type filter
        if (filterManager.filters.vetrinaType && filterManager.filters.vetrinaType !== 'all') {
            const fileTags = file.tags || [];
            if (!fileTags.includes(filterManager.filters.vetrinaType)) {
                return false;
            }
        }
        
        // Pages range filter
        if (typeof filterManager.filters.minPages === 'number' && typeof filterManager.filters.maxPages === 'number') {
            const filePages = file.pages || 0;
            if (filePages < filterManager.filters.minPages || filePages > filterManager.filters.maxPages) {
                return false;
            }
        }
        
        return true;
    });
}

function updateActiveFilterIndicators() {
    const indicators = document.querySelectorAll('.filter-indicator');
    indicators.forEach(indicator => {
        const filterType = indicator.getAttribute('data-filter-type');
        if (filterManager.filters[filterType]) {
            indicator.classList.add('active');
        } else {
            indicator.classList.remove('active');
        }
    });
}

function updateActiveFiltersDisplay() {
    filterManager.updateActiveFiltersDisplay();
}

function updateBottomFilterCount() {
    filterManager.updateBottomFilterCount();
}

// ===========================
// ACTIVE FILTER MANAGEMENT
// ===========================

function removeActiveFilter(filterKey, event, specificValue = null) {
    event?.preventDefault();
    event?.stopPropagation();
    
    if (specificValue) {
        // Remove specific value from array filter
        if (Array.isArray(filterManager.filters[filterKey])) {
            filterManager.filters[filterKey] = filterManager.filters[filterKey].filter(v => v !== specificValue);
            
            if (filterManager.filters[filterKey].length === 0) {
                delete filterManager.filters[filterKey];
            }
            
            // Update UI for multi-select filters
            if (!filterManager.filters[filterKey] || filterManager.filters[filterKey].length === 0) {
                const input = document.getElementById(`${filterKey}Filter`);
                if (input) input.value = '';
            } else if (filterManager.filters[filterKey].length === 1) {
                const input = document.getElementById(`${filterKey}Filter`);
                if (input) input.value = getTagDisplayName(filterManager.filters[filterKey][0]);
            }
        }
    } else {
        // Remove entire filter
        removeFilter(filterKey);
    }
    
    filterManager.setFilter(filterKey, filterManager.filters[filterKey]);
    applyFiltersAndRender();
}

function removeFilter(filterKey) {
    if (filterKey === 'priceRange') {
        // Reset price range but keep priceType
        delete filterManager.filters.minPrice;
        delete filterManager.filters.maxPrice;
        
        const minPriceRange = document.getElementById('minPriceRange');
        const maxPriceRange = document.getElementById('maxPriceRange');
        const minPriceValue = document.getElementById('minPriceValue');
        const maxPriceValue = document.getElementById('maxPriceValue');
        
        if (minPriceRange) minPriceRange.value = 0;
        if (maxPriceRange) maxPriceRange.value = 100;
        if (minPriceValue) minPriceValue.textContent = '€0';
        if (maxPriceValue) maxPriceValue.textContent = '€100';
        
        updatePriceSliderFill();
        
    } else if (filterKey === 'pagesRange') {
        // Reset pages range
        delete filterManager.filters.minPages;
        delete filterManager.filters.maxPages;
        
        const minPagesRange = document.getElementById('minPagesRange');
        const maxPagesRange = document.getElementById('maxPagesRange');
        const minPagesValue = document.getElementById('minPagesValue');
        const maxPagesValue = document.getElementById('maxPagesValue');
        
        if (minPagesRange) minPagesRange.value = 1;
        if (maxPagesRange) maxPagesRange.value = 1000;
        if (minPagesValue) minPagesValue.textContent = '1';
        if (maxPagesValue) maxPagesValue.textContent = '1000';
        
        updatePagesSliderFill();
        
    } else if (filterKey === 'minRating') {
        // Reset rating filter
        delete filterManager.filters.minRating;
        updateRatingFilterUI();
        
    } else {
        // Remove regular filter
        delete filterManager.filters[filterKey];
        
        // Reset UI element
        const input = document.getElementById(`${filterKey}Filter`);
        if (input) {
            input.value = '';
            input.placeholder = filterManager.getPlaceholderText(filterKey);
        }
        
        const selectedOptions = document.getElementById(`${filterKey}SelectedOptions`);
        if (selectedOptions) {
            selectedOptions.innerHTML = '';
        }
        
        // Reset radio buttons if applicable
        if (filterKey === 'priceType') {
            const allRadio = document.querySelector('input[name="priceType"][value="all"]');
            if (allRadio) allRadio.checked = true;
            filterManager.filters.priceType = 'all';
        }
        
        if (filterKey === 'vetrinaType') {
            const allRadio = document.querySelector('input[name="vetrinaType"][value="all"]');
            if (allRadio) allRadio.checked = true;
        }
    }
    
    // Save filters and apply
    saveFiltersToStorage();
    applyFiltersAndRender();
}

// ===========================
// SEARCH FUNCTIONALITY
// ===========================

async function performSearch(query) {
    if (!query || query.length < 2) {
        // Show all documents if query is too short
        currentFiles = originalFiles;
        renderDocuments(currentFiles);
        return;
    }
    
    const searchTerm = query.toLowerCase();
    
    // Filter files based on search query
    const searchResults = originalFiles.filter(file => {
        // Search in vetrina name
        const vetrinaName = (file.vetrina_info?.name || '').toLowerCase();
        if (vetrinaName.includes(searchTerm)) return true;
        
        // Search in vetrina description
        const vetrinaDescription = (file.vetrina_info?.description || '').toLowerCase();
        if (vetrinaDescription.includes(searchTerm)) return true;
        
        // Search in faculty name
        const facultyName = (file.faculty_name || '').toLowerCase();
        if (facultyName.includes(searchTerm)) return true;
        
        // Search in course name
        const courseName = (file.course_name || '').toLowerCase();
        if (courseName.includes(searchTerm)) return true;
        
        // Search in tags
        const tags = file.tags || [];
        if (tags.some(tag => tag.toLowerCase().includes(searchTerm))) return true;
        
        // Search in filename
        const filename = (file.filename || '').toLowerCase();
        if (filename.includes(searchTerm)) return true;
        
        return false;
    });
    
    // Apply any active filters to search results
    currentFiles = applyFiltersToFiles(searchResults);
    
    // Apply sorting
    const orderType = filterManager.filters.orderBy || 'relevance';
    currentFiles = sortDocuments(currentFiles, orderType);
    
    // Render results
    renderDocuments(currentFiles);
}

// ===========================
// AI SEARCH TOGGLE
// ===========================

function initializeAISearchToggle() {
    const aiToggle = document.getElementById('aiSearchToggle');
    const searchInput = document.getElementById('searchInput');
    
    if (!aiToggle || !searchInput) return;
    
    let isAIEnabled = false;
    
    aiToggle.addEventListener('change', () => {
        isAIEnabled = aiToggle.checked;
        updateSearchPlaceholder(isAIEnabled);
        
        // Clear current search when toggling
        searchInput.value = '';
        
        // Show/hide AI features
        if (isAIEnabled) {
            searchInput.classList.add('ai-enabled');
            startTypewriter();
        } else {
            searchInput.classList.remove('ai-enabled');
            stopTypewriter();
        }
    });
    
    // Search input handler
    searchInput.addEventListener('input', debounce(async (e) => {
        const query = e.target.value.trim();
        
        if (isAIEnabled && query.length > 2) {
            // AI search functionality would go here
            // For now, fall back to regular search
            await performSearch(query);
        } else if (!isAIEnabled) {
            await performSearch(query);
        }
    }, 300));
}

function updateSearchPlaceholder(aiEnabled) {
    const searchInput = document.getElementById('searchInput');
    if (!searchInput) return;
    
    if (aiEnabled) {
        searchInput.placeholder = 'Chiedi quello che vuoi in linguaggio naturale...';
    } else {
        searchInput.placeholder = 'Cerca documenti, corsi, argomenti...';
    }
}

// ===========================
// TYPEWRITER EFFECT FOR AI SEARCH
// ===========================

let typewriterInterval;
let typewriterCursorInterval;
let typewriterIndex = 0;
let typewriterPhraseIndex = 0;
let isTypewriterPaused = false;

const typewriterPhrases = [
    'Trova appunti di matematica...',
    'Dispense di fisica quantistica...',
    'Esami di programmazione...',
    'Progetti di ingegneria...',
    'Tesi di laurea in economia...'
];

function startTypewriter() {
    const searchInput = document.getElementById('searchInput');
    if (!searchInput || !searchInput.classList.contains('ai-enabled')) return;
    
    stopTypewriter(); // Clear any existing intervals
    typewriterIndex = 0;
    typewriterPhraseIndex = 0;
    
    async function typewriterLoop() {
        const phrase = typewriterPhrases[typewriterPhraseIndex];
        await typewriterPrintPhrase(phrase, searchInput);
        
        // Wait before deleting
        await new Promise(resolve => setTimeout(resolve, 2000));
        
        // Delete the phrase
        while (searchInput.placeholder.length > 0 && !isTypewriterPaused) {
            typewriterDeleteLetter(searchInput);
            await new Promise(resolve => setTimeout(resolve, 50));
        }
        
        // Move to next phrase
        typewriterPhraseIndex = (typewriterPhraseIndex + 1) % typewriterPhrases.length;
        
        // Wait before starting next phrase
        await new Promise(resolve => setTimeout(resolve, 500));
        
        if (!isTypewriterPaused) {
            typewriterLoop();
        }
    }
    
    typewriterLoop();
    startTypewriterCursor(searchInput);
}

function stopTypewriter() {
    isTypewriterPaused = true;
    if (typewriterInterval) {
        clearInterval(typewriterInterval);
        typewriterInterval = null;
    }
    stopTypewriterCursor();
}

function pauseTypewriter() {
    isTypewriterPaused = true;
}

function resumeTypewriter() {
    isTypewriterPaused = false;
    startTypewriter();
}

async function typewriterPrintPhrase(phrase, input) {
    for (let i = 0; i < phrase.length && !isTypewriterPaused; i++) {
        typewriterAddLetter(phrase[i], input);
        await new Promise(resolve => setTimeout(resolve, 100));
    }
}

function typewriterAddLetter(letter, input) {
    input.placeholder += letter;
}

function typewriterDeleteLetter(input) {
    input.placeholder = input.placeholder.slice(0, -1);
}

function startTypewriterCursor(input) {
    let cursorVisible = true;
    typewriterCursorInterval = setInterval(() => {
        if (cursorVisible) {
            input.style.setProperty('--cursor-opacity', '1');
        } else {
            input.style.setProperty('--cursor-opacity', '0');
        }
        cursorVisible = !cursorVisible;
    }, 530);
}

function stopTypewriterCursor() {
    if (typewriterCursorInterval) {
        clearInterval(typewriterCursorInterval);
        typewriterCursorInterval = null;
    }
}

// ===========================
// FAVORITES FUNCTIONALITY
// ===========================

async function refreshFavoriteStatus() {
    if (!checkAuthentication() || !originalFiles || originalFiles.length === 0) return;
    
    try {
        const data = await makeAuthenticatedRequest(`${API_BASE}/api/favorites`);
        if (data && data.favorites) {
            const favoriteIds = new Set(data.favorites.map(fav => fav.file_id));
            
            // Update originalFiles
            originalFiles.forEach(file => {
                file.is_favorite = favoriteIds.has(file.id);
            });
            
            // Update currentFiles if they exist
            if (currentFiles && currentFiles.length > 0) {
                currentFiles.forEach(file => {
                    file.is_favorite = favoriteIds.has(file.id);
                });
            }
            
            // Update UI
            updateFavoriteButtonsUI();
        }
    } catch (error) {
        console.warn('Could not refresh favorite status:', error);
    }
}

async function toggleFavorite(button, event) {
    event?.preventDefault();
    event?.stopPropagation();
    
    if (!checkAuthentication()) {
        showStatus('Accedi per aggiungere ai preferiti', 'error');
        return;
    }
    
    const fileId = button.getAttribute('data-file-id');
    if (!fileId) return;
    
    const icon = button.querySelector('i');
    const isCurrentlyFavorite = button.classList.contains('active');
    
    // Optimistic UI update
    if (isCurrentlyFavorite) {
        button.classList.remove('active');
        icon.textContent = 'favorite_border';
    } else {
        button.classList.add('active');
        icon.textContent = 'favorite';
    }
    
    try {
        const response = await makeAuthenticatedRequest(`${API_BASE}/api/favorites/toggle`, {
            method: 'POST',
            body: JSON.stringify({ file_id: fileId })
        });
        
        if (response && response.success) {
            // Update file data
            const updateFile = (file) => {
                if (file.id === fileId) {
                    file.is_favorite = !isCurrentlyFavorite;
                }
            };
            
            originalFiles?.forEach(updateFile);
            currentFiles?.forEach(updateFile);
            
            showStatus(
                isCurrentlyFavorite ? 'Rimosso dai preferiti' : 'Aggiunto ai preferiti',
                'success'
            );
        } else {
            throw new Error('Toggle favorite failed');
        }
    } catch (error) {
        // Revert optimistic update
        if (isCurrentlyFavorite) {
            button.classList.add('active');
            icon.textContent = 'favorite';
        } else {
            button.classList.remove('active');
            icon.textContent = 'favorite_border';
        }
        
        showError('Errore nell\'aggiornamento dei preferiti');
    }
}

function updateFavoriteButtonsUI() {
    const favoriteButtons = document.querySelectorAll('.favorite-btn');
    favoriteButtons.forEach(button => {
        const fileId = button.getAttribute('data-file-id');
        const file = originalFiles?.find(f => f.id === fileId);
        
        if (file) {
            const icon = button.querySelector('i');
            if (file.is_favorite) {
                button.classList.add('active');
                icon.textContent = 'favorite';
            } else {
                button.classList.remove('active');
                icon.textContent = 'favorite_border';
            }
        }
    });
}

// ===========================
// CART FUNCTIONALITY
// ===========================

async function addToCart(docId, event) {
    event?.preventDefault();
    event?.stopPropagation();
    
    if (!checkAuthentication()) {
        showStatus('Accedi per aggiungere al carrello', 'error');
        return;
    }
    
    try {
        const response = await makeAuthenticatedRequest(`${API_BASE}/api/cart/add`, {
            method: 'POST',
            body: JSON.stringify({ document_id: docId })
        });
        
        if (response && response.success) {
            showStatus('Documento aggiunto al carrello', 'success');
            
            // Update cart badge if it exists
            const cartBadge = document.getElementById('cartBadge');
            if (cartBadge && response.cart_count) {
                cartBadge.textContent = response.cart_count;
                cartBadge.style.display = 'block';
            }
        } else {
            throw new Error('Add to cart failed');
        }
    } catch (error) {
        showError('Errore nell\'aggiunta al carrello');
    }
}

// ===========================
// DOCUMENT PREVIEW & DOWNLOAD
// ===========================

async function previewDocument(fileId) {
    // This would open a modal with document preview
    // Implementation depends on your preview modal structure
    console.log('Preview document:', fileId);
    
    // You can implement the preview modal here
    // For now, just show a placeholder
    showStatus('Anteprima non ancora implementata', 'info');
}

function closePreview() {
    const previewModal = document.getElementById('previewModal');
    if (previewModal) {
        previewModal.classList.remove('active');
    }
}

async function downloadDocument(fileId) {
    if (!checkAuthentication()) {
        showStatus('Accedi per scaricare i documenti', 'error');
        return;
    }
    
    try {
        const response = await fetch(`${API_BASE}/api/files/${fileId}/download`, {
            headers: {
                'Authorization': `Bearer ${authToken}`
            }
        });
        
        if (!response.ok) {
            throw new Error('Download failed');
        }
        
        const blob = await response.blob();
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `document-${fileId}`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
        
        showStatus('Download avviato', 'success');
    } catch (error) {
        showError('Errore nel download del documento');
    }
}

async function purchaseDocument(fileId) {
    if (!checkAuthentication()) {
        showStatus('Accedi per acquistare i documenti', 'error');
        return;
    }
    
    // This would handle the purchase flow
    // For now, just add to cart
    await addToCart(fileId);
}

// ===========================
// STATUS & ERROR HANDLING
// ===========================

function showStatus(message, type = 'success') {
    // Remove any existing status
    const existingStatus = document.querySelector('.status-message');
    if (existingStatus) {
        existingStatus.remove();
    }
    
    // Create status element
    const status = document.createElement('div');
    status.className = `status-message ${type}`;
    status.innerHTML = `
        <div class="status-content">
            <i class="material-symbols-outlined">
                ${type === 'success' ? 'check_circle' : 
                  type === 'error' ? 'error' : 'info'}
            </i>
            <span>${message}</span>
        </div>
    `;
    
    // Add to page
    document.body.appendChild(status);
    
    // Show with animation
    setTimeout(() => status.classList.add('show'), 100);
    
    // Remove after delay
    setTimeout(() => {
        status.classList.remove('show');
        setTimeout(() => status.remove(), 300);
    }, 3000);
}

function showError(message) {
    showStatus(message, 'error');
}

// ===========================
// STORAGE UTILITIES
// ===========================

function saveFiltersToStorage() {
    try {
        const filtersToSave = { ...filterManager.filters };
        
        // Don't save tags in filters - they have their own storage
        if (filtersToSave.tag) {
            saveTagsToStorage(filtersToSave.tag);
            delete filtersToSave.tag;
        }
        
        localStorage.setItem('searchFilters', JSON.stringify(filtersToSave));
    } catch (e) {
        console.warn('Could not save filters to localStorage:', e);
    }
}

function restoreFiltersFromStorage() {
    try {
        const savedFilters = localStorage.getItem('searchFilters');
        const savedTags = getSavedTags();
        
        if (savedFilters) {
            const parsedFilters = JSON.parse(savedFilters);
            filterManager.filters = parsedFilters;
            
            // Restore tags separately
            if (savedTags && savedTags.length > 0) {
                filterManager.filters.tag = savedTags;
            }
            
            // Update UI to reflect restored filters
            updateFilterInputs();
            updateActiveFilterIndicators();
            updateActiveFiltersDisplay();
            
            // Apply restored filters
            applyFiltersAndRender();
        } else {
            // No saved filters - start fresh
            filterManager.filters = {};
        }
    } catch (e) {
        console.warn('Could not restore filters from localStorage:', e);
        filterManager.filters = {};
    }
}

function saveTagsToStorage(tags) {
    try {
        if (Array.isArray(tags) && tags.length > 0) {
            localStorage.setItem('searchTags', JSON.stringify(tags));
        } else {
            localStorage.removeItem('searchTags');
        }
    } catch (e) {
        console.warn('Could not save tags to localStorage:', e);
    }
}

function getSavedTags() {
    try {
        const savedTags = localStorage.getItem('searchTags');
        return savedTags ? JSON.parse(savedTags) : [];
    } catch (e) {
        console.warn('Could not get saved tags from localStorage:', e);
        return [];
    }
}

function clearSavedTags() {
    try {
        localStorage.removeItem('searchTags');
    } catch (e) {
        console.warn('Could not clear saved tags from localStorage:', e);
    }
}

function updateFilterInputs() {
    Object.entries(filterManager.filters).forEach(([key, value]) => {
        const input = document.getElementById(`${key}Filter`);
        if (input && typeof value === 'string') {
            input.value = value;
        }
        
        // Handle special cases
        if (key === 'priceType') {
            const radio = document.querySelector(`input[name="priceType"][value="${value}"]`);
            if (radio) radio.checked = true;
        }
        
        if (key === 'vetrinaType') {
            const radio = document.querySelector(`input[name="vetrinaType"][value="${value}"]`);
            if (radio) radio.checked = true;
        }
        
        if (key === 'minRating') {
            updateRatingFilterUI();
        }
        
        if (key === 'minPrice' || key === 'maxPrice') {
            const minPriceRange = document.getElementById('minPriceRange');
            const maxPriceRange = document.getElementById('maxPriceRange');
            const minPriceValue = document.getElementById('minPriceValue');
            const maxPriceValue = document.getElementById('maxPriceValue');
            
            if (filterManager.filters.minPrice !== undefined && minPriceRange) {
                minPriceRange.value = filterManager.filters.minPrice;
            }
            if (filterManager.filters.maxPrice !== undefined && maxPriceRange) {
                maxPriceRange.value = filterManager.filters.maxPrice;
            }
            if (minPriceValue) {
                minPriceValue.textContent = `€${filterManager.filters.minPrice || 0}`;
            }
            if (maxPriceValue) {
                maxPriceValue.textContent = `€${filterManager.filters.maxPrice || 100}`;
            }
            updatePriceSliderFill();
        }
        
        if (key === 'minPages' || key === 'maxPages') {
            const minPagesRange = document.getElementById('minPagesRange');
            const maxPagesRange = document.getElementById('maxPagesRange');
            const minPagesValue = document.getElementById('minPagesValue');
            const maxPagesValue = document.getElementById('maxPagesValue');
            
            if (filterManager.filters.minPages !== undefined && minPagesRange) {
                minPagesRange.value = filterManager.filters.minPages;
            }
            if (filterManager.filters.maxPages !== undefined && maxPagesRange) {
                maxPagesRange.value = filterManager.filters.maxPages;
            }
            if (minPagesValue) {
                minPagesValue.textContent = filterManager.filters.minPages || 1;
            }
            if (maxPagesValue) {
                maxPagesValue.textContent = filterManager.filters.maxPages || 1000;
            }
            updatePagesSliderFill();
        }
        
        if (key === 'tag' && Array.isArray(value)) {
            const selectedOptions = document.getElementById('tagSelectedOptions');
            if (selectedOptions) {
                selectedOptions.innerHTML = '';
                value.forEach(tag => {
                    const pill = document.createElement('div');
                    pill.className = 'selected-option-pill';
                    pill.innerHTML = `
                        <span>${getTagDisplayName(tag)}</span>
                        <button onclick="removeSpecificFilterValue('tag', '${tag}')">&times;</button>
                    `;
                    selectedOptions.appendChild(pill);
                });
            }
        }
    });
}

// ===========================
// UTILITY FUNCTIONS
// ===========================

function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
        const later = () => {
            clearTimeout(timeout);
            func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
    };
}

function formatDate(dateString) {
    const date = new Date(dateString);
    return date.toLocaleDateString('it-IT');
}

function logout() {
    localStorage.removeItem('authToken');
    localStorage.removeItem('currentUser');
    authToken = null;
    window.location.href = 'index.html';
}

// ===========================
// INITIALIZATION
// ===========================

function initializeAnimations() {
    // Remove static cards initialization since we'll load dynamic data
    setTimeout(() => {
        const cards = document.querySelectorAll('.document-card');
        cards.forEach((card, index) => {
            card.style.opacity = '1';
            card.style.transform = 'translateY(0)';
        });
    }, 500);
}

// Initialize the page
window.onload = async function() {
    // Show loading cards immediately when page loads
    showLoadingCards();
    
    // Force clear any cached data that might be causing issues
    if (sessionStorage.getItem('lastCacheBuster') !== CACHE_BUSTER.toString()) {
        sessionStorage.clear();
        sessionStorage.setItem('lastCacheBuster', CACHE_BUSTER.toString());
    }
    
    // Check authentication after showing loading state
    const isAuthenticated = checkAuthentication();
    
    // Initialize user info (will show login button if not authenticated)
    initializeUserInfo();
    
    // Initialize CSP-compliant event handlers
    handleCSPEventHandlers();
    
    initializeAnimations();
    initializeFilters();
    initializeAISearchToggle();
    
    // Load valid tags from backend first
    await loadValidTags();
    
    // Load files for both authenticated and guest users
    await loadAllFiles();

    // Ensure documents are shown after loading
    if (originalFiles && originalFiles.length > 0) {
        renderDocuments(originalFiles);
        currentFiles = originalFiles;
        showStatus(`${originalFiles.length} documenti disponibili 📚`);
    }
    
    // Small delay to ensure DOM is fully ready, then restore filters
    setTimeout(() => {
        restoreFiltersFromStorage();
        
        // Additional check to ensure all UI elements are properly updated
        setTimeout(() => {
            updateActiveFilterIndicators();
            updateActiveFiltersDisplay();
            
            // Final safety check - if no documents are shown, show all documents
            setTimeout(() => {
                const documentsGrid = document.getElementById('documentsGrid');
                if (documentsGrid && documentsGrid.children.length === 0 && originalFiles && originalFiles.length > 0) {
                    renderDocuments(originalFiles);
                    currentFiles = originalFiles;
                    showStatus(`${originalFiles.length} documenti disponibili 📚`);
                }
            }, 500);
        }, 50);
    }, 100);
    
    // Add keyboard shortcut to clear all filters (Ctrl/Cmd + Alt + C)
    document.addEventListener('keydown', function(e) {
        if ((e.ctrlKey || e.metaKey) && e.altKey && e.key === 'c') {
            e.preventDefault();
            clearAllFiltersAction();
        }
    });
    
    // Handle favorites refresh on page show
    window.addEventListener('pageshow', (event) => {
        const favoritesChanged = sessionStorage.getItem('favoritesChanged');
        
        if (favoritesChanged === 'true') {
            sessionStorage.removeItem('favoritesChanged');
            refreshFavoriteStatus();
        } else if (event.persisted) {
            refreshFavoriteStatus();
        }
    });
    
    // Mark when we're leaving the page
    let isLeavingPage = false;
    window.addEventListener('beforeunload', () => {
        isLeavingPage = true;
    });
    
    // Check if we're returning to the page and refresh favorites
    window.addEventListener('pageshow', async (event) => {
        if (isLeavingPage && currentFiles && currentFiles.length > 0) {
            isLeavingPage = false;
            setTimeout(async () => {
                await refreshFavoriteStatus();
            }, 200);
        }
    });
    
    // Handle browser back/forward navigation
    window.addEventListener('popstate', async (event) => {
        if (currentFiles && currentFiles.length > 0) {
            setTimeout(async () => {
                await refreshFavoriteStatus();
            }, 100);
        }
    });
};

// Close user dropdown when clicking elsewhere
document.addEventListener('click', () => {
    const userInfo = document.querySelector('.user-info');
    if (userInfo && userInfo.classList.contains('open')) {
        userInfo.classList.remove('open');
    }
});

// ===========================
// GLOBAL FUNCTION EXPORTS
// ===========================

// Make functions globally available for HTML onclick handlers
window.previewDocument = previewDocument;
window.closePreview = closePreview;
window.downloadDocument = downloadDocument;
window.purchaseDocument = purchaseDocument;
window.toggleFavorite = toggleFavorite;
window.removeFilter = removeFilter;
window.clearAllFiltersAction = clearAllFiltersAction;
window.selectDropdownOption = selectDropdownOption;
window.removeSpecificFilterValue = removeSpecificFilterValue;
window.filterManager = filterManager;